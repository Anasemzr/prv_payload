func (p *Proxy) listen() error {
  // Check for and set proxy if http_proxy environment variable is defined
  proxyURL := os.Getenv("http_proxy")
  if proxyURL != "" {
    proxy, err := proxy.Parse(URL(proxyURL)) // Use URL type for stricter parsing
    if err != nil {
      return fmt.Errorf("failed to parse proxy URL: %w", err)
    }
    // Create a custom dialer function using the proxy
    dialer := func(network, address string) (net.Conn, error) {
      return proxy.Dial("tcp", "localhost:http", proxy.Dialer(network, address))
    }
  } else {
    dialer = nil // No proxy, use default dialer
  }

  if p.remote.Stdio {
    //TODO check if pipes active?
  } else if p.remote.LocalProto == "tcp" {
    addr, err := net.ResolveTCPAddr("tcp", p.remote.LocalHost+":"+p.remote.LocalPort)
    if err != nil {
      return p.Errorf("resolve: %s", err)
    }
    // Use the custom dialer (if set) for dialing the listener
    var l net.Listener
    if dialer != nil {
      l, err = net.ListenTCP("tcp", addr, dialer)
    } else {
      l, err = net.ListenTCP("tcp", addr)
    }
    if err != nil {
      return p.Errorf("tcp: %s", err)
    }
    p.Infof("Listening")
    p.tcp = l
  } else if p.remote.LocalProto == "udp" {
    l, err := listenUDP(p.Logger, p.sshTun, p.remote)
    if err != nil {
      return err
    }
    p.Infof("Listening")
    p.udp = l
  } else {
    return p.Errorf("unknown local proto")
  }
  return nil
}
